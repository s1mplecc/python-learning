# 生成器

所有生成器都是迭代器，因为生成器完全实现了迭代器接口。不过，根据《设计模式：可复用面向对象软件的基础》一书的定义，迭代器用于从集合中取出元素，而生成器用于“凭空”生成元素。通过斐波那契数列能很好地说明二者之间的区别：斐波纳契数列中的数有无穷多个，无法将它们都装在一个集合里，但是生成器可以在每次需要时生成一项元素。因此，尽管 Python 社区中经常将迭代器和生成器视为同一概念，你也要明白生成器所具有的特殊语义。

#### 生成器函数

前面我们说到，生成器函数是包含了 yield 关键字的函数，调用生成器函数时会返回一个生成器对象。也就是说，生成器函数是生成器的工厂函数。因此，生成器函数和普通的函数有着显著的行为差异：即使没有 return 语句，生成器函数依然会返回一个生成器对象。就算有，定义在 yield 语句后的 return 返回值也会被忽略。

```python
>>> def gen():
...     yield 1
...     return 'a'
... 
>>> gen()
<generator object gen at 0x10ddd9820>
>>> list(gen())
[1]
```

"yield" 这个单词，除了产出还有**让步**的含义，对于生成器函数中的 yield 来说，这两个含义都成立。让步体现在，生成器函数在执行到 yield 语句产出值后，会作出让步，暂停执行生成器，让调用方继续工作，直到需要下一个值时再调用 `next()`。下面使用 for 循环来更清楚地说明生成器函数定义体的执行过程。

```python
>>> def gen_AB():
...     print('start')
...     yield 'A'
...     print('continue')
...     yield 'B'
...     print('end')
... 
>>> for c in gen_AB():
...     print('-->', c)
... 
start
--> A
continue
--> B
end
```

迭代时，for 机制的作用与 `g = iter(gen_AB())` 一样，生成器的 `__iter__` 方法会返回生成器对象本身，然后每次迭代时调用 `next(g)`。

* 在 for 循环中第一次隐式调用 next 函数时，会打印 'start'，然后停留在第一个 yield 语句，产出值 'A'；
* 第二次隐式调用 next 函数时，会打印 'continue'，然后停留在第一个 yield 语句，产出值 'B'；
* 第三次隐式调用 next 函数时，打印 'end'，到达函数定义体的末尾，导致生成器对象抛出 StopIteration 异常。for 机制会捕获异常，因此循环终止时不会报错。

如果显式调用 `next()` 方法，那么生成器函数定义体被执行的过程如下：

```python
>>> g = iter(gen_AB())
>>> next(g)
start
'A'
>>> next(g)
continue
'B'
>>> next(g)
end
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

在这个例子中你可以看到，定义在生成器函数体内的 print 语句并没有在生成器函数被调用时就立即打印，而被延迟到调用 `next(g)` 时才打印。同样，如果在生成器函数中加入复杂的处理逻辑，该逻辑只在被 `next()` 调用时才进行处理，从而达到延迟处理的目的。我们将生成器的这一特性归纳为**惰性求值**（lazy evaluation），即尽可能地延后求值，只在需要时才进行求值。这样做的优点是可以节省内存，还可能避免无用的处理。

与惰性求值相对的是**及早求值**（eager evaluation），比如之前介绍的列表推导，列表这种数据结构一定要求内部的元素是已明确其值的，并且会将完整的列表保存在内存中。因此，《Effective Python》中提出这么一条：**考虑用生成器来改写直接返回列表的函数**。实际上，Python 3 已经对一些原本原本返回列表的函数使用生成器进行了改写。比如 Python 2 中返回完整列表的 `range()` 函数，现在也返回一个类似生成器的对象。如果一定要让 `range()` 函数返回列表，必须明确指明，如 `list(range(100))`。

定义生成器函数时，唯一需要留意的就是：**函数返回的那个迭代器是有状态的**，调用者不应该反复使用它。

#### 生成器表达式

除了定义包含 yield 关键字的生成器函数可以返回生成器外，生成器表达式也可以返回生成器对象。相比于列表推导的及早求值，生成器表达式能够进行惰性求值：不会迫切地构建列表，而是返回一个生成器，按需产出元素。也就是说，如果说列表推导时构建列表的工厂，那么生成器表达式就是构建生成器的工厂。

生成器表达式与列表推导的唯一区别是使用了一对圆括号 "()" 代替列表推导中的中括号 "\[]"。我们使用之前定义的生成器函数 `gen_AB()` 来演示生成器表达式与列表推导之间的区别。

```python
>>> res1 = [x for x in gen_AB()]  # list comprehension
start
continue
end
>>> res1
['A', 'B']
>>> for x in res1:
...     print('-->', x)
... 
--> A
--> B
>>> res2 = (x for x in gen_AB())  # generator expression
>>> res2
<generator object <genexpr> at 0x10dea8f20>
>>> for x in res2:
...     print('-->', x)
... 
start
--> A
continue
--> B
end
```

归因于列表的及早求值，在声明列表推导表达式时，`gen_AB()` 函数中的 print 语句被立即执行了，函数产出的两个值 'A'、'B' 也被存放在构建出的列表中。而生成器表达式则将这个过程推迟到值真正需要之时，即 for 循环隐式调用 `next()` 之时。

前面提到，生成器对象是有状态的，这里体现在，一个生成器对象产出的值只能被消费一次，除非定义一个新的个生成器对象重新绑定。你可以想象成，生成器对象中存在不能回头的“指针”，每次调用 `next()` 方法时指向下一个元素，这个过程不可逆。所以对于同一个生成器对象重复调用时可能会产生意想不到的结果。比如下面代码中第二次调用 `list(res2)` 返回一个空列表，因为第一次调用时“指针”就已经到头了。

```python
>>> res2 = (x for x in gen_AB())
>>> list(res2)
start
continue
end
['A', 'B']
>>> list(res2)
[]
>>> next(res2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

所以如果要对生成器对象进行多次迭代，一种方法是使用列表将生成器中的所有元素备份下来，另一种是定义一个新的生成器对象重新绑定。由此可见，尽管生成器对象相比列表能够通过惰性求值节省内存，但如果每次迭代时定义新的生成器对象，求值过程也会被重复多次。而列表推导只会在声明时进行一次求值，并将结果保存在列表中可供多次迭代调用，这其实是一种空间消耗和时间消耗的权衡。

#### yield from

刚才所提到的生成器产出值被消费的概念，也侧面体现了生成器可以作为“协程”的语义。“协程”从字面意思理解就是协作的进程，协作的进程之间需要进行通信，就需要消费者和生产者之间建立通道。从 Python 3.3 开始引入了一个新的句法：`yield from`，类似于其他语言中的 await 关键字。它可以在两个生成器之间建立通道，将产出的值从一个生成器传输到另一个生成器。

如果生成器函数需要产出其他生成器的值，传统的做法是使用 for 循环遍历生成器的元素并产出。以下定义了一个能够产出多个生成器产出值的生成器函数。

```python
>>> def chain(*iterables):
...     for it in iterables:
...         for i in it:
...             yield i
... 
>>> g1 = (x for x in 'ABC')
>>> g2 = (x for x in (0, 1))
>>> list(chain(g1, g2))
['A', 'B', 'C', 0, 1]
```

引入的 `yield from` 句法可以直接将一个生成器的所有产出值产出，而不用遍历生成器对象。因此我们可以编写只有一层的 for 循环：

```python
>>> def chain(*iterables):
...     for it in iterables:
...         yield from it
... 
>>> g1 = (x for x in 'ABC')
>>> g2 = (x for x in (0, 1))
>>> chain(g1, g2)
<generator object chain at 0x10dea8e40>
>>> list(chain(g1, g2))
['A', 'B', 'C', 0, 1]
```

chain 函数依然返回一个生成器对象，其中的 `yield from it` 语句对 it 对象所做的第一件事是调用 `iter(it)` 获得一个迭代器，所以 it 对象可以是任何可迭代对象。我们将 `yield from <iterable>` 表达式中用于获取值的 `<iterable>` 称为**子生成器**（subgenerator），即上面代码中的 g1、g2；将包含了 `yield from` 语句的生成器函数，即 chain 函数，称为委派生成器。`yield from` 的主要功能是打开双向通道，把最外层的调用层与最内层的子生成器连接起来，这样二者可以直接发送和产出值。

上述的例子只能勉强算一个协程的案例，其中的“协作”部分体现的不够明显，只是简单的将一个生成器的值传输给另一个生成器产出。真正的协作应该是通过生成器对象的 `send()` 方法将值从客户端传输给生成器。在后面章节我们会专门介绍协程，里面会提及生成器的 `send()`、`throw()` 和 `close()` 方法，以及 `yield from` 句法的其他作用。
